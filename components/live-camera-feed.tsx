"use client"

import { useState, useRef, useEffect } from "react"
import { Button } from "@/components/ui/button"
import { Card } from "@/components/ui/card"

interface LiveCameraFeedProps {
  onAnalysisComplete: (analysis: any) => void
  exerciseType?: string
  isProviderMode?: boolean
}

export function LiveCameraFeed({ onAnalysisComplete, exerciseType, isProviderMode = false }: LiveCameraFeedProps) {
  const [isStreaming, setIsStreaming] = useState(false)
  const [isAnalyzing, setIsAnalyzing] = useState(false)
  const [analysis, setAnalysis] = useState<any>(null)
  const [error, setError] = useState<string | null>(null)
  const [painLevel, setPainLevel] = useState(0)
  const [exerciseCount, setExerciseCount] = useState(0)
  
  const videoRef = useRef<HTMLVideoElement>(null)
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const streamRef = useRef<MediaStream | null>(null)
  const analysisIntervalRef = useRef<NodeJS.Timeout | null>(null)

  const startCamera = async () => {
    try {
      setError(null)
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          width: { ideal: 1280 },
          height: { ideal: 720 },
          facingMode: 'user'
        },
        audio: false
      })
      
      if (videoRef.current) {
        videoRef.current.srcObject = stream
        streamRef.current = stream
        setIsStreaming(true)
        startAnalysis()
      }
    } catch (err) {
      setError('Unable to access camera. Please check permissions.')
      console.error('Camera error:', err)
    }
  }

  const stopCamera = () => {
    if (streamRef.current) {
      streamRef.current.getTracks().forEach(track => track.stop())
      streamRef.current = null
    }
    if (analysisIntervalRef.current) {
      clearInterval(analysisIntervalRef.current)
      analysisIntervalRef.current = null
    }
    setIsStreaming(false)
    setIsAnalyzing(false)
  }

  const startAnalysis = () => {
    setIsAnalyzing(true)
    
    // Real-time analysis with Python backend
    analysisIntervalRef.current = setInterval(async () => {
      if (videoRef.current && canvasRef.current) {
        const canvas = canvasRef.current
        const video = videoRef.current
        const ctx = canvas.getContext('2d')
        
        if (ctx) {
          canvas.width = video.videoWidth
          canvas.height = video.videoHeight
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height)
          
          try {
            // Convert canvas to base64
            const frameData = canvas.toDataURL('image/jpeg', 0.8).split(',')[1]
            
            // Send to Python backend for analysis
            const response = await fetch('/api/live/analyze', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                frameData: frameData,
                exerciseType: exerciseType || 'general',
                patientId: 'demo-patient'
              })
            })

            if (response.ok) {
              const result = await response.json()
              if (result.success && result.analysis) {
                const analysis = {
                  ...result.analysis,
                  painLevel: painLevel,
                  repCount: exerciseCount,
                  recommendations: generateRecommendations()
                }
                
                setAnalysis(analysis)
                onAnalysisComplete(analysis)
              }
            } else {
              // Fallback to mock analysis if backend fails
              const mockAnalysis = {
                timestamp: new Date().toISOString(),
                exerciseType: exerciseType || 'General',
                formScore: Math.floor(Math.random() * 30) + 70,
                painLevel: painLevel,
                repCount: exerciseCount,
                feedback: generateFeedback(),
                keypoints: generateMockKeypoints(),
                compensations: generateMockCompensations(),
                recommendations: generateRecommendations()
              }
              
              setAnalysis(mockAnalysis)
              onAnalysisComplete(mockAnalysis)
            }
          } catch (error) {
            console.error('Analysis error:', error)
            // Fallback to mock analysis
            const mockAnalysis = {
              timestamp: new Date().toISOString(),
              exerciseType: exerciseType || 'General',
              formScore: Math.floor(Math.random() * 30) + 70,
              painLevel: painLevel,
              repCount: exerciseCount,
              feedback: generateFeedback(),
              keypoints: generateMockKeypoints(),
              compensations: generateMockCompensations(),
              recommendations: generateRecommendations()
            }
            
            setAnalysis(mockAnalysis)
            onAnalysisComplete(mockAnalysis)
          }
        }
      }
    }, 2000) // Analyze every 2 seconds to reduce load
  }

  const generateFeedback = () => {
    const feedbacks = [
      "Great form! Keep your back straight.",
      "Slight knee valgus detected. Focus on knee alignment.",
      "Good depth on that squat!",
      "Engage your core more for better stability.",
      "Excellent range of motion.",
      "Try to keep your chest up.",
      "Good tempo, nice and controlled.",
      "Watch your breathing pattern."
    ]
    return feedbacks[Math.floor(Math.random() * feedbacks.length)]
  }

  const generateMockKeypoints = () => {
    return [
      { name: 'nose', x: 0.5, y: 0.2, confidence: 0.95 },
      { name: 'left_shoulder', x: 0.4, y: 0.3, confidence: 0.92 },
      { name: 'right_shoulder', x: 0.6, y: 0.3, confidence: 0.91 },
      { name: 'left_hip', x: 0.45, y: 0.6, confidence: 0.93 },
      { name: 'right_hip', x: 0.55, y: 0.6, confidence: 0.94 },
      { name: 'left_knee', x: 0.42, y: 0.8, confidence: 0.90 },
      { name: 'right_knee', x: 0.58, y: 0.8, confidence: 0.91 },
      { name: 'left_ankle', x: 0.4, y: 1.0, confidence: 0.86 },
      { name: 'right_ankle', x: 0.6, y: 1.0, confidence: 0.88 }
    ]
  }

  const generateMockCompensations = () => {
    const compensations = [
      { joint: 'left_knee', type: 'valgus_collapse', severity: 'mild' },
      { joint: 'lower_back', type: 'excessive_rounding', severity: 'moderate' },
      { joint: 'right_hip', type: 'anterior_tilt', severity: 'mild' }
    ]
    return Math.random() > 0.7 ? [compensations[Math.floor(Math.random() * compensations.length)]] : []
  }

  const generateRecommendations = () => {
    const recommendations = [
      "Focus on engaging your glutes",
      "Keep your knees tracking over your toes",
      "Maintain a neutral spine",
      "Breathe deeply throughout the movement",
      "Slow down the tempo for better control"
    ]
    return [recommendations[Math.floor(Math.random() * recommendations.length)]]
  }

  const incrementRep = () => {
    setExerciseCount(prev => prev + 1)
  }

  const resetSession = () => {
    setExerciseCount(0)
    setPainLevel(0)
    setAnalysis(null)
  }

  useEffect(() => {
    return () => {
      stopCamera()
    }
  }, [])

  return (
    <div className="space-y-4">
      <Card className="p-6">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold">
            {isProviderMode ? 'Patient Exercise Monitoring' : 'Live Exercise Analysis'}
          </h3>
          <div className="flex gap-2">
            {!isStreaming ? (
              <Button onClick={startCamera} className="bg-green-600 hover:bg-green-700">
                Start Camera
              </Button>
            ) : (
              <Button onClick={stopCamera} variant="destructive">
                Stop Camera
              </Button>
            )}
          </div>
        </div>

        {error && (
          <div className="mb-4 p-3 bg-red-100 border border-red-400 text-red-700 rounded">
            {error}
          </div>
        )}

        <div className="relative">
          <video
            ref={videoRef}
            autoPlay
            playsInline
            muted
            className={`w-full h-64 md:h-96 bg-gray-900 rounded-lg ${!isStreaming ? 'hidden' : ''}`}
          />
          <canvas
            ref={canvasRef}
            className="hidden"
          />
          
          {!isStreaming && (
            <div className="w-full h-64 md:h-96 bg-gray-100 rounded-lg flex items-center justify-center">
              <div className="text-center">
                <div className="w-16 h-16 bg-gray-300 rounded-full flex items-center justify-center mx-auto mb-4">
                  <svg className="w-8 h-8 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                  </svg>
                </div>
                <p className="text-gray-600">Click "Start Camera" to begin live analysis</p>
              </div>
            </div>
          )}

          {isAnalyzing && (
            <div className="absolute top-4 right-4 bg-green-500 text-white px-3 py-1 rounded-full text-sm font-medium">
              AI Analyzing...
            </div>
          )}
        </div>

        {/* Exercise Controls */}
        {isStreaming && (
          <div className="mt-4 flex gap-4 items-center">
            <Button onClick={incrementRep} className="bg-blue-600 hover:bg-blue-700">
              Count Rep
            </Button>
            <Button onClick={resetSession} variant="outline">
              Reset Session
            </Button>
            
            <div className="flex items-center gap-2">
              <label className="text-sm font-medium">Pain Level:</label>
              <input
                type="range"
                min="0"
                max="10"
                value={painLevel}
                onChange={(e) => setPainLevel(parseInt(e.target.value))}
                className="w-20"
              />
              <span className="text-sm text-gray-600">{painLevel}</span>
            </div>
          </div>
        )}

        {/* Real-time Analysis Display */}
        {analysis && (
          <div className="mt-4 grid grid-cols-1 md:grid-cols-3 gap-4">
            <div className="bg-blue-50 p-3 rounded-lg">
              <div className="text-sm font-medium text-blue-800">Form Score</div>
              <div className="text-2xl font-bold text-blue-600">{analysis.formScore}/100</div>
            </div>
            
            <div className="bg-green-50 p-3 rounded-lg">
              <div className="text-sm font-medium text-green-800">Rep Count</div>
              <div className="text-2xl font-bold text-green-600">{analysis.repCount}</div>
            </div>
            
            <div className="bg-red-50 p-3 rounded-lg">
              <div className="text-sm font-medium text-red-800">Pain Level</div>
              <div className="text-2xl font-bold text-red-600">{analysis.painLevel}/10</div>
            </div>
          </div>
        )}

        {/* Live Feedback */}
        {analysis && (
          <div className="mt-4 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
            <div className="text-sm font-medium text-yellow-800 mb-2">Live Feedback:</div>
            <div className="text-yellow-700">{analysis.feedback}</div>
            
            {analysis.compensations.length > 0 && (
              <div className="mt-2">
                <div className="text-sm font-medium text-red-800">Compensations Detected:</div>
                <ul className="text-red-700 text-sm">
                  {analysis.compensations.map((comp: any, index: number) => (
                    <li key={index}>• {comp.joint}: {comp.type} ({comp.severity})</li>
                  ))}
                </ul>
              </div>
            )}
            
            {analysis.recommendations.length > 0 && (
              <div className="mt-2">
                <div className="text-sm font-medium text-blue-800">Recommendations:</div>
                <ul className="text-blue-700 text-sm">
                  {analysis.recommendations.map((rec: string, index: number) => (
                    <li key={index}>• {rec}</li>
                  ))}
                </ul>
              </div>
            )}
          </div>
        )}
      </Card>
    </div>
  )
}
